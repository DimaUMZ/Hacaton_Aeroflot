### **Этап 4: Разработка Frontend'а**

Этот этап посвящен созданию интуитивно понятного, отзывчивого и надежного пользовательского интерфейса, который позволяет авиаинженерам быстро и без ошибок фиксировать операции с инструментами.

---

#### **Детализация стека технологий и обоснование**

*   **Фреймворк: React.** Выбор обусловлен его доминирующим положением на рынке, огромным сообществом, богатейшей экосистемой библиотек и предсказуемостью кода на основе JSX. Это снижает риски и ускоряет разработку.
*   **Язык: TypeScript.** **Критически важен для надежности.** TypeScript статически проверяет типы данных, что позволяет отлавливать до 15% ошибок ещё на этапе написания кода (опечатки в именах свойств, неверные типы параметров функций). Это абсолютно необходимо для сложных интерфейсов с большим количеством состояний и взаимодействий с API.
*   **Сборка: Vite.** Современный, невероятно быстрый инструмент для сборки проектов. Обеспечивает мгновенный запуск dev-сервера и горячее обновление модулей (HMR), что drastically улучшает опыт разработки по сравнению с Create React App.
*   **UI-библиотека: MUI (Material-UI).** Предоставляет огромную коллекцию готовых, профессионально выглядящих, доступных и кастомизируемых компонентов (кнопки, таблицы, диалоги, карточки). Это позволяет не тратить время на стилизацию "с нуля" и обеспечить единообразие интерфейса, как того требует ТЗ.
*   **Работа с камерой: `react-webcam`.** Простая и популярная библиотека-обертка для Native HTML5 API, предоставляющая удобные React-компоненты и хуки для работы с видеопотоком пользовательской камеры.
*   **Управление состоянием: React Query (TanStack Query) + встроенные хуки.** Для асинхронного состояния (запросы к API) используем React Query. Он предоставляет кэширование, фоновое обновление, инвалидацию данных и обработку ошибок "из коробки". Для локального состояния UI (открыт/закрыт модал, значение поля ввода) используем `useState`, `useReducer`.
*   **HTTP-клиент: Axios.** Надежная библиотека для выполнения HTTP-запросов с удобным API, интерцепторами и поддержкой отмены запросов.

---

#### **Подробная архитектура Frontend'а с образцами кода**

**1. Структура проекта**
```
src/
├── components/          # Переиспользуемые UI-компоненты
│   ├── ui/             # Базовые компоненты (кнопки, модалы)
│   ├── camera/         # Компонент работы с камерой
│   └── layout/         # Компоненты макета (шапка, боковая панель)
├── pages/              # Страницы приложения
│   ├── LoginPage.tsx
│   ├── CheckoutPage.tsx  # Выдача
│   ├── CheckinPage.tsx   # Сдача
│   └── HistoryPage.tsx
├── hooks/              # Кастомные React-хуки
│   ├── useAuth.ts
│   └── useApi.ts
├── services/           # Слой для работы с API
│   └── api.ts
├── types/              # TypeScript-типы
│   └── index.ts
├── utils/              # Вспомогательные функции
│   └── constants.ts
├── App.tsx
└── main.tsx
```

**2. TypeScript-типы (контракты данных)**
`src/types/index.ts`
```typescript
// Типы, соответствующие Pydantic-схемам на бэкенде
export interface DetectedTool {
  class_name: string;
  confidence: number;
}

export interface RecognitionRequest {
  image_base64: string;
  operation_type: 'checkin' | 'checkout';
  toolkit_id: number;
}

export interface Operation {
  id: number;
  user_id: number;
  toolkit_id: number;
  operation_type: string;
  timestamp: string; // ISO string
  status: 'success' | 'discrepancy' | 'manual_check';
  result_json?: {
    detected_tools: DetectedTool[];
    match_percentage?: number;
    missing_tools?: string[];
    extra_tools?: string[];
  };
}

export interface Toolkit {
  id: number;
  name: string;
  tool_list: string[];
}
```

**3. Сервис для работы с API**
`src/services/api.ts`
```typescript
import axios from 'axios';
import { RecognitionRequest, Operation, Toolkit } from '../types';

// Создаем экземпляр Axios с базовым URL и интерцептором для добавления JWT-токена
const apiClient = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000/api/v1',
});

// Интерцептор для добавления токена к каждому запросу
apiClient.interceptors.request.use((config) => {
  const token = localStorage.getItem('authToken');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export const api = {
  auth: {
    login: (badgeId: string, password: string) =>
      apiClient.post('/auth/login', { badge_id: badgeId, password }),
  },
  recognition: {
    process: (data: RecognitionRequest) =>
      apiClient.post<Operation>('/recognize', data),
  },
  history: {
    getOperations: () => apiClient.get<Operation[]>('/history'),
  },
  toolkits: {
    getToolkits: () => apiClient.get<Toolkit[]>('/toolkits'),
  },
};
```

**4. Кастомный хук для работы с камерой (на базе react-webcam)**
`src/components/camera/CameraCapture.tsx`
```typescript
import React, { useRef, useCallback, useState } from 'react';
import Webcam from 'react-webcam';

interface CameraCaptureProps {
  onCapture: (imageData: string) => void; // callback с base64 изображением
  isDisabled?: boolean;
}

export const CameraCapture: React.FC<CameraCaptureProps> = ({ onCapture, isDisabled }) => {
  const webcamRef = useRef<Webcam>(null);
  const [isCapturing, setIsCapturing] = useState(false);

  // Функция захвата кадра
  const capture = useCallback(() => {
    if (!webcamRef.current || isDisabled) return;
    setIsCapturing(true);
    
    const imageSrc = webcamRef.current.getScreenshot();
    if (imageSrc) {
      onCapture(imageSrc); // Передаем данные наверх
    }
    
    // Небольшая задержка для UX
    setTimeout(() => setIsCapturing(false), 500);
  }, [webcamRef, onCapture, isDisabled]);

  return (
    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '16px' }}>
      <Webcam
        audio={false}
        ref={webcamRef}
        screenshotFormat="image/jpeg"
        videoConstraints={{ width: 1280, height: 720, facingMode: 'environment' }} // Используем заднюю камеру
        style={{ width: '100%', maxWidth: '720px', borderRadius: '8px' }}
      />
      <Button
        variant="contained"
        color="primary"
        onClick={capture}
        disabled={isDisabled || isCapturing}
        startIcon={<CameraAltIcon />}
      >
        {isCapturing ? 'Захватываем...' : 'Захватить изображение'}
      </Button>
    </div>
  );
};
```

**5. Главная страница процесса сдачи (Checkin)**
`src/pages/CheckinPage.tsx`
```typescript
import React, { useState } from 'react';
import {
  Container,
  Typography,
  Box,
  Paper,
  Alert,
  CircularProgress,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import { CameraCapture } from '../components/camera/CameraCapture';
import { useApi } from '../hooks/useApi';
import { Operation } from '../types';

export const CheckinPage: React.FC = () => {
  const [currentResult, setCurrentResult] = useState<Operation | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const { api } = useApi();

  const handleImageCapture = async (imageBase64: string) => {
    setIsLoading(true);
    setError(null);
    try {
      // Предполагаем, что toolkit_id выбран из списка ранее
      const selectedToolkitId = 1; 
      const response = await api.recognition.process({
        image_base64: imageBase64.split(',')[1], // Убираем префикс data:image/jpeg;base64,
        operation_type: 'checkin',
        toolkit_id: selectedToolkitId,
      });
      setCurrentResult(response.data);
    } catch (err: any) {
      setError(err.response?.data?.detail || 'Произошла ошибка при обработке');
    } finally {
      setIsLoading(false);
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'success':
        return <CheckCircleIcon color="success" />;
      case 'discrepancy':
        return <ErrorIcon color="error" />;
      default:
        return null;
    }
  };

  return (
    <Container maxWidth="md">
      <Box sx={{ my: 4 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Сдача инструмента
        </Typography>
        <Typography variant="body1" paragraph>
          Разложите все инструменты из комплекта в поле зрения камеры и нажмите "Захватить изображение"
        </Typography>

        <CameraCapture onCapture={handleImageCapture} isDisabled={isLoading} />

        {isLoading && (
          <Box sx={{ display: 'flex', justifyContent: 'center', my: 3 }}>
            <CircularProgress />
            <Typography variant="body2" sx={{ ml: 2 }}>
              Идёт распознавание...
            </Typography>
          </Box>
        )}

        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {error}
          </Alert>
        )}

        {currentResult && (
          <Paper elevation={3} sx={{ p: 3, mt: 3 }}>
            <Typography variant="h6" gutterBottom>
              Результат проверки комплекта
            </Typography>
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 2 }}>
              {getStatusIcon(currentResult.status)}
              <Typography variant="body1" sx={{ ml: 1 }}>
                Статус: {currentResult.status === 'success' ? 'Комплект полный' : 'Обнаружены расхождения'}
              </Typography>
            </Box>

            {currentResult.result_json && (
              <>
                <Typography variant="body2">
                  Процент совпадения: <strong>{currentResult.result_json.match_percentage}%</strong>
                </Typography>

                {currentResult.result_json.missing_tools && currentResult.result_json.missing_tools.length > 0 && (
                  <>
                    <Typography variant="subtitle2" sx={{ mt: 2 }}>Отсутствующие инструменты:</Typography>
                    <List dense>
                      {currentResult.result_json.missing_tools.map((tool) => (
                        <ListItem key={tool}>
                          <ListItemIcon>
                            <ErrorIcon color="error" />
                          </ListItemIcon>
                          <ListItemText primary={tool} />
                        </ListItem>
                      ))}
                    </List>
                  </>
                )}

                {currentResult.result_json.extra_tools && currentResult.result_json.extra_tools.length > 0 && (
                  <>
                    <Typography variant="subtitle2" sx={{ mt: 2 }}>Лишние инструменты:</Typography>
                    <List dense>
                      {currentResult.result_json.extra_tools.map((tool) => (
                        <ListItem key={tool}>
                          <ListItemIcon>
                            <ErrorIcon color="warning" />
                          </ListItemIcon>
                          <ListItemText primary={tool} />
                        </ListItem>
                      ))}
                    </List>
                  </>
                )}
              </>
            )}
          </Paper>
        )}
      </Box>
    </Container>
  );
};
```

**6. Интеграция React Query для запроса истории**
`src/hooks/useApi.ts`
```typescript
import { useQuery } from '@tanstack/react-query';
import { api } from '../services/api';
import { Operation } from '../types';

export const useOperationsHistory = () => {
  return useQuery<Operation[], Error>({
    queryKey: ['operations'],
    queryFn: async () => {
      const response = await api.history.getOperations();
      return response.data;
    },
    staleTime: 5 * 60 * 1000, // Кэшируем данные на 5 минут
  });
};

// Использование в компоненте HistoryPage
// const { data: operations, isLoading, error } = useOperationsHistory();
```

**7. Точка входа (main.tsx) с провайдерами**
`src/main.tsx`
```typescript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ThemeProvider, createTheme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { App } from './App';

// Создаем клиент для React Query
const queryClient = new QueryClient();

// Тема MUI для единообразия стилей
const theme = createTheme({
  palette: {
    mode: 'light',
    primary: {
      main: '#1976d2', // Классический синий Material-UI
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <ThemeProvider theme={theme}>
        <CssBaseline /> {/* Сброс CSS и базовые стили */}
        <App />
      </ThemeProvider>
    </QueryClientProvider>
  </React.StrictMode>,
);
```

---

#### **Ключевые преимущества такой архитектуры:**

1.  **Надежность:** TypeScript и строгая типизация сводят к минимуму runtime-ошибки.
2.  **Производительность:** Vite обеспечивает быструю сборку и разработку. React Query эффективно управляет кэшированием и состоянием запросов.
3.  **Согласованность интерфейса:** MUI предоставляет единую дизайн-систему, что ускоряет разработку и улучшает пользовательский опыт.
4.  **Модульность:** Четкое разделение на компоненты, хуки и сервисы делает код поддерживаемым и легко тестируемым.
5.  **Соответствие ТЗ:** Интуитивно понятный интерфейс с минимальным количеством необходимых элементов, решающий конкретные задачи пользователя.
