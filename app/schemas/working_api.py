# app/schemas/working_api.py
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer
from sqlalchemy import create_engine, Column, Integer, String, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import sessionmaker, Session, declarative_base
from sqlalchemy.sql import func
from datetime import datetime, timedelta
from jose import JWTError, jwt
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from contextlib import asynccontextmanager
import hashlib
import uvicorn
import uuid
import logging
import os

# ===== –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø =====
SECRET_KEY = "your-secret-key-change-in-production"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
DATABASE_URL = "sqlite:///./tools.db"

# –ö–æ–¥—ã –æ—à–∏–±–æ–∫
ERROR_CODES = {
    "ML_SERVICE_UNAVAILABLE": {
        "code": "API_ERR_001",
        "message": "ML —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ –∫–æ–º–ø—å—é—Ç–µ—Ä–Ω–æ–≥–æ –∑—Ä–µ–Ω–∏—è."
    },
    "IMAGE_PROCESSING_ERROR": {
        "code": "API_ERR_002", 
        "message": "–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è."
    },
    "DETECTION_SERVICE_ERROR": {
        "code": "API_ERR_003",
        "message": "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è. –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ—Ç–µ–∫—Ü–∏—é –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤."
    },
    "OPERATION_NOT_FOUND": {
        "code": "API_ERR_004",
        "message": "–û–ø–µ—Ä–∞—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å session_id."
    },
    "INVALID_IMAGE_DATA": {
        "code": "API_ERR_005",
        "message": "–ù–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –∏–ª–∏ –∏–º–µ–µ—Ç –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç."
    },
    "DATABASE_ERROR": {
        "code": "API_ERR_006",
        "message": "–û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö."
    }
}

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# ===== –ë–ê–ó–ê –î–ê–ù–ù–´–• =====
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    badge_id = Column(String, unique=True, index=True)
    full_name = Column(String)
    hashed_password = Column(String)
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)

class Operation(Base):
    __tablename__ = "operations"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    operation_type = Column(String)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    status = Column(String, default="in_progress")
    session_id = Column(String)
    engineer_name = Column(String)

# ===== ML –°–ï–†–í–ò–° =====
try:
    from ml_service import detection_service
    ML_AVAILABLE = detection_service is not None
    print("‚úÖ ML —Å–µ—Ä–≤–∏—Å –¥–æ—Å—Ç—É–ø–µ–Ω")
except ImportError as e:
    print(f"‚ö†Ô∏è ML —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
    ML_AVAILABLE = False
except Exception as e:
    print(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ ML —Å–µ—Ä–≤–∏—Å–∞: {e}")
    ML_AVAILABLE = False

# ===== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =====
def hash_password(password: str) -> str:
    """–ü—Ä–æ—Å—Ç–æ–µ —Ö–µ—à–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–∞—Ä–æ–ª—è –¥–ª—è –¥–µ–º–æ"""
    return hashlib.sha256(f"{password}{SECRET_KEY}".encode()).hexdigest()

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞—Ä–æ–ª—è"""
    return hash_password(plain_password) == hashed_password

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_demo_data():
    """–°–æ–∑–¥–∞–µ—Ç –¥–µ–º–æ-–¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ"""
    db = SessionLocal()
    try:
        if not db.query(User).first():
            demo_user = User(
                badge_id="demo",
                full_name="–ò–≤–∞–Ω–æ–≤ –ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤–∏—á",
                hashed_password=hash_password("password"),
                is_active=True,
                is_superuser=False
            )
            admin_user = User(
                badge_id="admin", 
                full_name="–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –°–∏—Å—Ç–µ–º—ã",
                hashed_password=hash_password("admin"),
                is_active=True,
                is_superuser=True
            )
            db.add_all([demo_user, admin_user])
            db.commit()
            print("‚úÖ Demo data created successfully")
    except Exception as e:
        print(f"‚ùå Error creating demo data: {e}")
    finally:
        db.close()

# ===== LIFESPAN MANAGEMENT =====
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    print("üîß Starting up...")
    Base.metadata.create_all(bind=engine)
    create_demo_data()
    yield
    # Shutdown
    print("üîß Shutting down...")

# ===== PYDANTIC –°–•–ï–ú–´ =====
class LoginRequest(BaseModel):
    badge_id: str
    password: str

class UserResponse(BaseModel):
    id: int
    badge_id: str
    full_name: str
    is_active: bool
    is_superuser: bool

    class Config:
        from_attributes = True

class Token(BaseModel):
    access_token: str
    token_type: str
    user: UserResponse

class ErrorResponse(BaseModel):
    error_code: str
    error_message: str
    details: Optional[str] = None

# ===== FASTAPI –ü–†–ò–õ–û–ñ–ï–ù–ò–ï =====
app = FastAPI(
    title="Tool Management System API",
    version="1.0.0",
    lifespan=lifespan
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000", "*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def read_root():
    return {
        "message": "Tool Management System API", 
        "version": "1.0.0",
        "ml_available": ML_AVAILABLE
    }

@app.get("/api/health")
async def health_check():
    return {
        "status": "healthy", 
        "timestamp": datetime.now().isoformat(),
        "service": "Tool Management System API",
        "ml_available": ML_AVAILABLE
    }

@app.get("/api/ml/status")
async def get_ml_status():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ ML —Å–µ—Ä–≤–∏—Å–∞"""
    if ML_AVAILABLE:
        return {
            "ml_available": True,
            "available_tools": detection_service.get_available_tools(),
            "message": "ML —Å–µ—Ä–≤–∏—Å –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ"
        }
    else:
        return {
            "ml_available": False,
            "available_tools": [],
            "message": "ML —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
        }

@app.post("/api/ml/detect")
async def detect_tools(request: dict):
    """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Å –ø–æ–º–æ—â—å—é ML –º–æ–¥–µ–ª–∏"""
    if not ML_AVAILABLE:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=ErrorResponse(
                error_code=ERROR_CODES["ML_SERVICE_UNAVAILABLE"]["code"],
                error_message=ERROR_CODES["ML_SERVICE_UNAVAILABLE"]["message"],
                details="ML —Å–µ—Ä–≤–∏—Å –Ω–µ –∑–∞–ø—É—â–µ–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
            ).dict()
        )
    
    try:
        image_base64 = request.get("image_base64", "")
        confidence_threshold = request.get("confidence_threshold", 0.5)
        
        if not image_base64:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=ErrorResponse(
                    error_code=ERROR_CODES["INVALID_IMAGE_DATA"]["code"],
                    error_message=ERROR_CODES["INVALID_IMAGE_DATA"]["message"],
                    details="–ü–æ–ª–µ image_base64 –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º"
                ).dict()
            )
        
        # –í—ã–ø–æ–ª–Ω—è–µ–º –¥–µ—Ç–µ–∫—Ü–∏—é
        results = detection_service.detect_tools(image_base64, confidence_threshold)
        
        return {
            "success": True,
            "results": results,
            "available_tools": detection_service.get_available_tools()
        }
        
    except Exception as e:
        logger.error(f"Error in tool detection: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=ErrorResponse(
                error_code=ERROR_CODES["DETECTION_SERVICE_ERROR"]["code"],
                error_message=ERROR_CODES["DETECTION_SERVICE_ERROR"]["message"],
                details=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è: {str(e)}"
            ).dict()
        )

@app.post("/api/auth/login", response_model=Token)
async def login(login_data: LoginRequest, db: Session = Depends(get_db)):
    """–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    print(f"üîê Login attempt: {login_data.badge_id}")
    
    user = db.query(User).filter(User.badge_id == login_data.badge_id).first()
    
    if not user:
        # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –¥–µ–º–æ
        if login_data.badge_id in ["demo", "admin"]:
            is_superuser = login_data.badge_id == "admin"
            full_name = "–ò–≤–∞–Ω–æ–≤ –ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤–∏—á" if not is_superuser else "–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –°–∏—Å—Ç–µ–º—ã"
            
            user = User(
                badge_id=login_data.badge_id,
                full_name=full_name,
                hashed_password=hash_password(login_data.password),
                is_superuser=is_superuser
            )
            db.add(user)
            db.commit()
            db.refresh(user)
            print(f"‚úÖ Created new user: {login_data.badge_id}")
        else:
            print(f"‚ùå Invalid credentials: {login_data.badge_id}")
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid badge ID or password"
            )
    
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å
    if not verify_password(login_data.password, user.hashed_password):
        print(f"‚ùå Invalid password for: {login_data.badge_id}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid badge ID or password"
        )
    
    # –°–æ–∑–¥–∞–µ–º —Ç–æ–∫–µ–Ω
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = jwt.encode(
        {
            "sub": user.badge_id,
            "exp": datetime.utcnow() + access_token_expires,
            "user_id": user.id
        },
        SECRET_KEY,
        algorithm=ALGORITHM
    )
    
    print(f"‚úÖ Login successful: {user.full_name}")
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user": UserResponse.from_orm(user)
    }

@app.get("/api/auth/me")
async def get_current_user(token: str = Depends(HTTPBearer())):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ"""
    try:
        payload = jwt.decode(token.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        badge_id = payload.get("sub")
        
        db = SessionLocal()
        user = db.query(User).filter(User.badge_id == badge_id).first()
        db.close()
        
        if not user:
            raise HTTPException(status_code=404, detail="User not found")
        
        return UserResponse.from_orm(user)
        
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.post("/api/operations/start")
async def start_operation(operation_data: dict, db: Session = Depends(get_db)):
    """–ù–∞—á–∞–ª–æ –Ω–æ–≤–æ–π –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–º–∏"""
    print(f"üîß Starting operation for engineer: {operation_data.get('engineer_name')}")
    
    try:
        session_id = str(uuid.uuid4())
        
        operation = Operation(
            user_id=operation_data.get('user_id', 1),
            operation_type=operation_data.get('operation_type', 'checkout'),
            session_id=session_id,
            engineer_name=operation_data.get('engineer_name', ''),
            status="in_progress"
        )
        
        db.add(operation)
        db.commit()
        db.refresh(operation)
        
        print(f"‚úÖ Operation started: {session_id}")
        
        return {
            "session_id": session_id,
            "operation_id": operation.id,
            "message": "Operation started successfully"
        }
    except Exception as e:
        logger.error(f"Database error in start_operation: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=ErrorResponse(
                error_code=ERROR_CODES["DATABASE_ERROR"]["code"],
                error_message=ERROR_CODES["DATABASE_ERROR"]["message"],
                details=f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é: {str(e)}"
            ).dict()
        )

@app.post("/api/operations/confirm")
async def confirm_operation(confirm_data: dict, db: Session = Depends(get_db)):
    """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é ML –¥–µ—Ç–µ–∫—Ü–∏–∏"""
    print(f"‚úÖ Confirming operation: {confirm_data.get('session_id')}")
    
    try:
        operation = db.query(Operation).filter(
            Operation.session_id == confirm_data.get("session_id")
        ).first()
        
        if not operation:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=ErrorResponse(
                    error_code=ERROR_CODES["OPERATION_NOT_FOUND"]["code"],
                    error_message=ERROR_CODES["OPERATION_NOT_FOUND"]["message"],
                    details=f"–û–ø–µ—Ä–∞—Ü–∏—è —Å session_id {confirm_data.get('session_id')} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"
                ).dict()
            )
        
        # –ï—Å–ª–∏ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º ML –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏
        image_base64 = confirm_data.get("image_base64")
        ml_used = False
        tools_data = []
        
        if image_base64:
            if ML_AVAILABLE:
                try:
                    ml_results = detection_service.detect_tools(image_base64)
                    if ml_results["success"]:
                        # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã ML
                        tools_data = ml_results["results"]["detected_tools"]
                        ml_used = True
                        print(f"üîç ML detected {len(tools_data)} tools")
                    else:
                        raise HTTPException(
                            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                            detail=ErrorResponse(
                                error_code=ERROR_CODES["DETECTION_SERVICE_ERROR"]["code"],
                                error_message=ERROR_CODES["DETECTION_SERVICE_ERROR"]["message"],
                                details="ML —Å–µ—Ä–≤–∏—Å –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É –ø—Ä–∏ –¥–µ—Ç–µ–∫—Ü–∏–∏"
                            ).dict()
                        )
                except Exception as e:
                    logger.error(f"ML detection failed: {e}")
                    raise HTTPException(
                        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
                        detail=ErrorResponse(
                            error_code=ERROR_CODES["DETECTION_SERVICE_ERROR"]["code"],
                            error_message=ERROR_CODES["DETECTION_SERVICE_ERROR"]["message"],
                            details=f"–û—à–∏–±–∫–∞ ML –¥–µ—Ç–µ–∫—Ü–∏–∏: {str(e)}"
                        ).dict()
                    )
            else:
                raise HTTPException(
                    status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                    detail=ErrorResponse(
                        error_code=ERROR_CODES["ML_SERVICE_UNAVAILABLE"]["code"],
                        error_message=ERROR_CODES["ML_SERVICE_UNAVAILABLE"]["message"],
                        details="–ù–µ–æ–±—Ö–æ–¥–∏–º–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –¥–µ—Ç–µ–∫—Ü–∏–∏, –Ω–æ ML —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω"
                    ).dict()
                )
        else:
            # –ï—Å–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–æ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ø–∏—Å–æ–∫ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
            tools_data = []
            print("‚ÑπÔ∏è No image provided for detection")
        
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –æ–ø–µ—Ä–∞—Ü–∏–∏
        operation.status = "completed"
        db.commit()
        
        return {
            "message": "Operation confirmed successfully",
            "operation_id": operation.id,
            "tools": tools_data,
            "total_tools": len(tools_data),
            "match_percentage": 95.0 if tools_data else 0,
            "ml_used": ml_used
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Database error in confirm_operation: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=ErrorResponse(
                error_code=ERROR_CODES["DATABASE_ERROR"]["code"],
                error_message=ERROR_CODES["DATABASE_ERROR"]["message"],
                details=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏: {str(e)}"
            ).dict()
        )

@app.get("/api/users")
async def get_users(db: Session = Depends(get_db)):
    """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)"""
    try:
        users = db.query(User).all()
        return [UserResponse.from_orm(user) for user in users]
    except Exception as e:
        logger.error(f"Database error in get_users: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=ErrorResponse(
                error_code=ERROR_CODES["DATABASE_ERROR"]["code"],
                error_message=ERROR_CODES["DATABASE_ERROR"]["message"],
                details=f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {str(e)}"
            ).dict()
        )

if __name__ == "__main__":
    print("üöÄ Starting Tool Management System API")
    print("üìç URL: http://localhost:8001")
    print("üìö Documentation: http://localhost:8001/docs")
    print("üîß Health Check: http://localhost:8001/api/health")
    print(f"ü§ñ ML Service: {'‚úÖ Available' if ML_AVAILABLE else '‚ùå Not available'}")
    print("=" * 50)
    
    uvicorn.run(
        app,
        host="0.0.0.0", 
        port=8001,
        reload=False
    )