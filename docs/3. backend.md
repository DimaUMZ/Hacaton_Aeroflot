### **Этап 3: Разработка Backend'а**

Этот этап посвящен созданию "мозга" приложения — серверной части, которая координирует работу фронтенда, ML-сервиса и базы данных, обеспечивает бизнес-логику и безопасность.

---

#### **Детализация стека технологий и обоснование**

*   **Язык: Python.** Этот выбор обеспечивает бесшовную интеграцию с ML-стеком (YOLOv8, OpenCV, Albumentations), что упрощает разработку и维护 (maintenance). Мы можем использовать одни и те же виртуальные окружения и контейнеры.
*   **Web-фреймворк: FastAPI.** Это не просто рекомендация, это идеальный выбор для данной задачи.
    *   **Производительность:** Сопоставима с Node.js и Go благодаря асинхронной работе (ASGI). Это критично для обработки изображений, которые могут быть большими.
    *   **Автогенерация OpenAPI/Swagger:** Прямое выполнение требования ТЗ. FastAPI из коробки генерирует интерактивную и актуальную документацию API.
    *   **Валидация данных на основе типов:** Использует Pydantic, что исключает множество ошибок на этапе разработки и обеспечивает надежность.
    *   **Встроенная поддержка асинхронности:** Позволяет эффективно обрабатывать множество I/O-операций (запросы к БД, вызовы ML-сервиса) без блокировок.
*   **База данных: PostgreSQL.** SQLite подходит только для демо. PostgreSQL — промышленная СУБД с надежностью, конкурентным доступом, сложными запросами и полноценной системой прав доступа.
*   **ORM: SQLAlchemy с async mode.** Классический, мощный и гибкий ORM. Асинхронная версия (`asyncpg` в качестве драйвера) позволяет полностью раскрыть потенциал асинхронного FastAPI.
*   **Аутентификация: JWT (JSON Web Tokens).** Стандарт де-факто для REST API. Не требует хранения состояния на сервере, легко масштабируется.

---

#### **Подробная архитектура Backend'а с образцами кода**

**1. Структура проекта (рекомендуемая)**
```
app/
├── api/           # Маршруты (endpoints)
│   ├── endpoints/
│   │   ├── auth.py
│   │   ├── recognition.py
│   │   └── history.py
│   └── deps.py    # Зависимости (например, get_current_user)
├── core/          # Ядро приложения (конфиги, безопасность)
│   ├── config.py
│   └── security.py
├── crud/          # Операции CRUD для работы с БД
│   └── crud_operation.py
├── db/            # Сессии и модели БД
│   ├── session.py
│   └── models.py
├── ml_client/     # Клиент для взаимодействия с ML-сервисом
│   └── client.py
├── schemas/       # Pydantic-схемы для валидации запросов/ответов
│   ├── tool_schema.py
│   └── user_schema.py
├── services/      # Бизнес-логика
│   └── recognition_service.py
└── main.py        # Точка входа
```

**2. Модели Базы Данных (SQLAlchemy ORM)**
`app/db/models.py`
```python
from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, JSON, Boolean
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship

Base = declarative_base()

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    badge_id = Column(String, unique=True, index=True, nullable=False) # ID бейджа
    full_name = Column(String, nullable=False)
    hashed_password = Column(String, nullable=False)
    is_active = Column(Boolean, default=True)
    is_superuser = Column(Boolean, default=False)

    operations = relationship("Operation", back_populates="user")

class Toolkit(Base):
    __tablename__ = "toolkits"

    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, unique=True, index=True, nullable=False) # "Набор для RRJ"
    description = Column(String)
    tool_list = Column(JSON, nullable=False) # Список инструментов в комплекте, напр.: ["screwdriver_plus", "pliers", ...]

class Operation(Base):
    __tablename__ = "operations"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    toolkit_id = Column(Integer, ForeignKey("toolkits.id"), nullable=False)
    operation_type = Column(String, nullable=False) # "checkout" (выдача) или "checkin" (сдача)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    result_json = Column(JSON) # Результат работы ML: {"detected_tools": [...], "match_percentage": 95.0}
    status = Column(String) # "success", "discrepancy", "manual_check"

    user = relationship("User", back_populates="operations")
    toolkit = relationship("Toolkit")
```

**3. Pydantic-схемы (для валидации и сериализации)**
`app/schemas/operation_schema.py`
```python
from pydantic import BaseModel
from datetime import datetime
from typing import List, Optional

# Схема для инструмента, обнаруженного ML
class DetectedTool(BaseModel):
    class_name: str
    confidence: float

    class Config:
        from_attributes = True # Работа с ORM

# Схема для запроса на распознавание
class RecognitionRequest(BaseModel):
    image_base64: str  # Изображение, закодированное в base64
    operation_type: str  # 'checkin' или 'checkout'
    toolkit_id: int  # ID комплекта для сверки

# Схема ответа от ML-сервиса
class MLServiceResponse(BaseModel):
    detected_tools: List[DetectedTool]
    match_percentage: Optional[float] = None
    missing_tools: Optional[List[str]] = None
    extra_tools: Optional[List[str]] = None

# Схема для ответа с результатом операции
class OperationResponse(BaseModel):
    id: int
    user_id: int
    toolkit_id: int
    operation_type: str
    timestamp: datetime
    status: str
    result_json: Optional[dict] = None

    class Config:
        from_attributes = True
```

**4. Клиент для вызова ML-сервиса**
`app/ml_client/client.py`
```python
import httpx
from app.core.config import settings
from app.schemas.operation_schema import MLServiceResponse

class MLClient:
    def __init__(self):
        self.base_url = settings.ML_SERVICE_URL # Напр., "http://ml-service:8001"

    async def recognize_tools(self, image_bytes: bytes) -> MLServiceResponse:
        """Отправляет изображение в ML-сервис и возвращает результат распознавания."""
        async with httpx.AsyncClient() as client:
            files = {"file": ("image.jpg", image_bytes, "image/jpeg")}
            try:
                response = await client.post(f"{self.base_url}/predict", files=files, timeout=30.0)
                response.raise_for_status()
                return MLServiceResponse(**response.json())
            except httpx.RequestError as e:
                # Логируем ошибку и пробрасываем ее дальше
                raise HTTPException(status_code=503, detail="ML service is unavailable") from e

ml_client = MLClient()
```

**5. Сервисный слой с бизнес-логикой**
`app/services/recognition_service.py`
```python
from app.ml_client.client import ml_client
from app.schemas.operation_schema import MLServiceResponse, RecognitionRequest
from app.crud.operation import create_operation
from app.db.session import get_db_session

class RecognitionService:
    async def process_recognition(self, request: RecognitionRequest, user_id: int, db):
        # 1. Декодируем изображение из base64
        import base64
        image_data = base64.b64decode(request.image_base64)

        # 2. Вызываем ML-сервис
        ml_result: MLServiceResponse = await ml_client.recognize_tools(image_data)

        # 3. (Для операции сдачи 'checkin') Получаем эталонный комплект из БД и сверяем
        if request.operation_type == "checkin":
            toolkit = await get_toolkit_from_db(request.toolkit_id, db)
            expected_tools = toolkit.tool_list
            detected_tool_names = [tool.class_name for tool in ml_result.detected_tools]

            # Вычисляем процент совпадения (упрощенная логика)
            correctly_detected = set(expected_tools) & set(detected_tool_names)
            match_percentage = (len(correctly_detected) / len(expected_tools)) * 100

            ml_result.match_percentage = round(match_percentage, 2)
            ml_result.missing_tools = list(set(expected_tools) - set(detected_tool_names))
            ml_result.extra_tools = list(set(detected_tool_names) - set(expected_tools))

            # 4. Определяем статус операции на основе порога
            threshold = 95.0  # Порог из конфига
            status = "success" if match_percentage >= threshold else "discrepancy"

        # 5. Сохраняем операцию в БД
        operation_data = {
            "user_id": user_id,
            "toolkit_id": request.toolkit_id,
            "operation_type": request.operation_type,
            "status": status,
            "result_json": ml_result.dict() # Сохраняем весь результат
        }
        db_operation = await create_operation(db, operation_data)

        return {"operation": db_operation, "ml_result": ml_result}

recognition_service = RecognitionService()
```

**6. Конечная точка (Endpoint) API**
`app/api/endpoints/recognition.py`
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.schemas.operation_schema import RecognitionRequest, OperationResponse
from app.services.recognition_service import recognition_service
from app.api.deps import get_current_active_user # Зависимость для аутентификации

router = APIRouter()

@router.post("/recognize", response_model=OperationResponse)
async def recognize_tools(
    request: RecognitionRequest,
    db: AsyncSession = Depends(get_db),
    current_user = Depends(get_current_active_user),
):
    """
    Основной endpoint для приема и выдачи инструментов.
    Принимает изображение в base64, тип операции и ID комплекта.
    Возвращает результат распознавания и сохраненную операцию.
    """
    try:
        result = await recognition_service.process_recognition(request, current_user.id, db)
        return result["operation"]
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        # Логируем непредвиденную ошибку
        raise HTTPException(status_code=500, detail="Internal server error during processing.")

# Endpoint для получения истории операций
@router.get("/history", response_model=list[OperationResponse])
async def read_operations(skip: int = 0, limit: int = 100, db: AsyncSession = Depends(get_db)):
    operations = await get_operations(db, skip=skip, limit=limit)
    return operations
```

**7. Настройка и запуск приложения**
`app/main.py`
```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from app.api.endpoints import auth, recognition, history
from app.db.session import engine, Base
from app.core.config import settings

# Создаем все таблицы в БД (В продакшене используем Alembic для миграций!)
async def create_tables():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

app = FastAPI(
    title="Tool Recognition API",
    description="API для автоматизированного учета авиаинструментов",
    version="1.0.0",
)

# Настройка CORS для фронтенда
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.BACKEND_CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Подключаем роутеры
app.include_router(auth.router, prefix="/auth", tags=["auth"])
app.include_router(recognition.router, prefix="/api/v1", tags=["recognition"])
app.include_router(history.router, prefix="/api/v1", tags=["history"])

@app.on_event("startup")
async def on_startup():
    await create_tables()

@app.get("/")
async def root():
    return {"message": "Tool Recognition API is running!"}

# Теперь по адресу /docs будет доступна автоматическая документация Swagger UI!
```

---

#### **Ключевые преимущества такой архитектуры:**

1.  **Чистота кода:** Разделение на модули (схемы, модели, сервисы, API) делает код поддерживаемым и тестируемым.
2.  **Асинхронность:** Все I/O-операции (запросы к БД, вызовы ML-сервиса) не блокируют работу сервера, обеспечивая высокую производительность.
3.  **Безопасность:** JWT-аутентификация защищает endpoints. Pydantic валидирует все входящие данные.
4.  **Документация:** Автогенерируемая Swagger UI-документация (`/docs`) всегда актуальна и прямо соответствует коду.
5.  **Готовность к масштабированию:** Микросервисная архитектура (отдельный ML-сервис) позволяет независимо масштабировать компоненты.
